# 📘 Study Notebook: Requirements Gathering and Analysis  
**Student:** Abner Soberon  
**Course:** Foundations of Programming  
**Date:** 2025-04-16  
**Lesson:** Requirements Gathering and Analysis  

---

## 📌 Objective  
In this lesson, you will identify and describe the methods of requirements gathering and the steps in requirements analysis.

---

## 📚 Lesson Structure

1. Introduction  
2. Requirements Gathering  
3. Feasibility Study  
4. Software Requirements Specification (SRS)  
5. Analyzing Requirements  
6. Summary  
7. Mastery Test (Results & Reflections)

---

## 1. 📘 Introduction

- The first step in a new software project is to gather **requirements** from the client.
- Requirements define **what the product must do**, and **by when**.
- This process takes place during the **analysis phase** of the Software Development Life Cycle (SDLC).

---

## 2. 🔍 Requirements Gathering

### 🔹 Methods:
- **Interviews**: Direct, personalized discussions.
- **Questionnaires**: Distributed surveys for broader input.
- **Document Searches**: Examination of existing records or manuals.
- **Observations**: Watching users in their daily tasks.
- **Meetings**: Collaborative discussions for clarification.

### 🔹 Types of Requirements:
- **Business**: What the business needs as outcome.
- **Functional**: What the software must do.
- **Non-Functional**: How the software should perform.

---

## 3. 🧪 Feasibility Study

A study to assess whether the project should proceed.

### 🔹 Four Aspects:
- **Technical**: Are resources and technology available?
- **Operational**: Will the product work for the client?
- **Economic**: Will it be cost-effective?
- **Schedule**: Can it be delivered on time?

---

## 4. 📄 Software Requirements Specification (SRS)

### 🔹 Purpose:
- Formal agreement between developer and client.
- Defines exactly what will be built.

### 🔹 Benefits:
- Reduces development effort and recoding.
- Helps estimate cost and timeline.
- Serves as a base for future enhancements.

### 🔹 Characteristics:
- **Correct**
- **Precise**
- **Complete**
- **Traceable**

### 🔹 SRS Structure:
1. **Introduction**: Purpose, Scope, Definitions, References, Overview.
2. **General Description**: Product perspective, functions, users, constraints, assumptions.
3. **Specific Requirements**:
   - External Interface Requirements
   - Functional and Non-Functional Requirements
   - Use Cases
   - Design Constraints
   - Logical Database Requirements
   - Other Requirements

---

## 5. 🧠 Analyzing Requirements

### 🔹 Purpose:
- Clarify vague or conflicting requirements.
- Prepare the framework for design.

### 🔹 Two Levels:
1. **System-Level Analysis**:
   - Identify technical and process issues.
   - File and document problems.
   - Use prototypes if needed.
2. **Software-Level Analysis**:
   - Drives software architecture and detailed design.

---

## 6. 📌 Summary

| Section | Key Points |
|---------|------------|
| **Requirements Gathering** | Use interviews, questionnaires, observations, etc. |
| **Feasibility Study** | Evaluate technical, operational, economic, and timeline factors. |
| **SRS** | Organizes and formalizes all gathered requirements. |
| **Analyzing Requirements** | Divided into system-level and software-level examination. |

---

## 7. ✅ Mastery Test Results

### Question 1: ❌  
Misinterpretation by system. User correctly identified system-level and software-level phases, plus contradiction analysis.

### Question 2: ✅  
Correctly matched each feasibility type with its definition using logical deduction.

### Question 3: ✅  
Identified "observations" as the correct method for studying day-to-day activities.

### Question 4: ✅  
Identified that performance-based time constraints belong in Non-Functional Requirements.

### Question 5: ✅  
Correctly selected "questionnaires" for providing a set of questions, despite justifiable skepticism of the method's effectiveness.

---

## 🧠 Reflection Logged

> *Sometimes the very structure of a problem contains implicit hints to its own solution.*  
> Recognizing this allowed the student to correctly solve matching problems by analyzing terminology and logical context—without needing to recall the lesson verbatim.

---

**End of notebook**
